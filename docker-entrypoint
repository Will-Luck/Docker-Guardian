#!/usr/bin/env sh

# Docker-Guardian: dependency-aware container recovery
# Forked from willfarrell/docker-autoheal (MIT)
# Adds: dependency monitoring, backup awareness, grace period, Watchtower awareness

set -e
# shellcheck disable=2039
set -o pipefail

DOCKER_SOCK=${DOCKER_SOCK:-/var/run/docker.sock}
UNIX_SOCK=""
CURL_TIMEOUT=${CURL_TIMEOUT:-30}
WEBHOOK_URL=${WEBHOOK_URL:-""}
WEBHOOK_JSON_KEY=${WEBHOOK_JSON_KEY:-"text"}
APPRISE_URL=${APPRISE_URL:-""}

# only use unix domain socket if no TCP endpoint is defined
case "${DOCKER_SOCK}" in
  "tcp://"*) HTTP_ENDPOINT="$(echo "${DOCKER_SOCK}" | sed 's#tcp://#http://#')"
             ;;
  "tcps://"*) HTTP_ENDPOINT="$(echo "${DOCKER_SOCK}" | sed 's#tcps://#https://#')"
             CA="--cacert /certs/ca.pem"
             CLIENT_KEY="--key /certs/client-key.pem"
             CLIENT_CERT="--cert /certs/client-cert.pem"
             ;;
  *)         HTTP_ENDPOINT="http://localhost"
             UNIX_SOCK="--unix-socket ${DOCKER_SOCK}"
             ;;
esac

# Original autoheal config
AUTOHEAL_CONTAINER_LABEL=${AUTOHEAL_CONTAINER_LABEL:-autoheal}
AUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD:-0}
AUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL:-5}
AUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT:-10}
AUTOHEAL_ONLY_MONITOR_RUNNING=${AUTOHEAL_ONLY_MONITOR_RUNNING:-false}

# Docker-Guardian config
AUTOHEAL_MONITOR_DEPENDENCIES=${AUTOHEAL_MONITOR_DEPENDENCIES:-true}
AUTOHEAL_DEPENDENCY_START_DELAY=${AUTOHEAL_DEPENDENCY_START_DELAY:-5}
AUTOHEAL_BACKUP_LABEL=${AUTOHEAL_BACKUP_LABEL:-"docker-volume-backup.stop-during-backup"}
AUTOHEAL_BACKUP_CONTAINER=${AUTOHEAL_BACKUP_CONTAINER:-""}
AUTOHEAL_GRACE_PERIOD=${AUTOHEAL_GRACE_PERIOD:-300}
AUTOHEAL_WATCHTOWER_COOLDOWN=${AUTOHEAL_WATCHTOWER_COOLDOWN:-300}
AUTOHEAL_WATCHTOWER_SCOPE=${AUTOHEAL_WATCHTOWER_SCOPE:-all}
AUTOHEAL_WATCHTOWER_EVENTS=${AUTOHEAL_WATCHTOWER_EVENTS:-orchestration}

# Notification events (keywords or numbers, comma-separated)
NOTIFY_EVENTS=${NOTIFY_EVENTS:-"actions"}

# Notification services
NOTIFY_GOTIFY_URL=${NOTIFY_GOTIFY_URL:-""}
NOTIFY_GOTIFY_TOKEN=${NOTIFY_GOTIFY_TOKEN:-""}
NOTIFY_DISCORD_WEBHOOK=${NOTIFY_DISCORD_WEBHOOK:-""}
NOTIFY_SLACK_WEBHOOK=${NOTIFY_SLACK_WEBHOOK:-""}
NOTIFY_TELEGRAM_TOKEN=${NOTIFY_TELEGRAM_TOKEN:-""}
NOTIFY_TELEGRAM_CHAT_ID=${NOTIFY_TELEGRAM_CHAT_ID:-""}
NOTIFY_PUSHOVER_TOKEN=${NOTIFY_PUSHOVER_TOKEN:-""}
NOTIFY_PUSHOVER_USER=${NOTIFY_PUSHOVER_USER:-""}
NOTIFY_PUSHBULLET_TOKEN=${NOTIFY_PUSHBULLET_TOKEN:-""}
NOTIFY_LUNASEA_WEBHOOK=${NOTIFY_LUNASEA_WEBHOOK:-""}
NOTIFY_EMAIL_SMTP=${NOTIFY_EMAIL_SMTP:-""}
NOTIFY_EMAIL_FROM=${NOTIFY_EMAIL_FROM:-""}
NOTIFY_EMAIL_TO=${NOTIFY_EMAIL_TO:-""}
NOTIFY_EMAIL_USER=${NOTIFY_EMAIL_USER:-""}
NOTIFY_EMAIL_PASS=${NOTIFY_EMAIL_PASS:-""}

# Normalise NOTIFY_EVENTS early so it's available for startup logging
_normalise_notify_events() {
  local raw="$1" result=""
  case "$raw" in
    all)   echo "startup,actions,skips"; return ;;
    debug) echo "startup,actions,skips,debug"; return ;;
  esac
  local IFS=","
  for item in $raw; do
    item=$(echo "$item" | tr -d ' ')
    case "$item" in
      1|startup)    result="${result},startup" ;;
      2|actions)    result="${result},actions" ;;
      3|failures)   result="${result},failures" ;;
      4|skips)      result="${result},skips" ;;
      5|debug)      result="${result},startup,actions,skips,debug" ;;
      all)          result="${result},startup,actions,skips" ;;
      *)            echo "WARNING: Unknown NOTIFY_EVENTS value: $item" >&2 ;;
    esac
  done
  echo "${result#,}"
}
NOTIFY_EVENTS_RESOLVED=$(_normalise_notify_events "$NOTIFY_EVENTS")

echo "Docker-Guardian (forked from docker-autoheal)"
echo "============================================="
echo AUTOHEAL_CONTAINER_LABEL=${AUTOHEAL_CONTAINER_LABEL}
echo AUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD}
echo AUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL}
echo AUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT}
echo AUTOHEAL_ONLY_MONITOR_RUNNING=${AUTOHEAL_ONLY_MONITOR_RUNNING}
echo AUTOHEAL_MONITOR_DEPENDENCIES=${AUTOHEAL_MONITOR_DEPENDENCIES}
echo AUTOHEAL_DEPENDENCY_START_DELAY=${AUTOHEAL_DEPENDENCY_START_DELAY}
echo AUTOHEAL_BACKUP_LABEL=${AUTOHEAL_BACKUP_LABEL}
echo AUTOHEAL_BACKUP_CONTAINER=${AUTOHEAL_BACKUP_CONTAINER}
echo AUTOHEAL_GRACE_PERIOD=${AUTOHEAL_GRACE_PERIOD}
echo AUTOHEAL_WATCHTOWER_COOLDOWN=${AUTOHEAL_WATCHTOWER_COOLDOWN}
echo AUTOHEAL_WATCHTOWER_SCOPE=${AUTOHEAL_WATCHTOWER_SCOPE}
echo AUTOHEAL_WATCHTOWER_EVENTS=${AUTOHEAL_WATCHTOWER_EVENTS}

# Log configured notification services (no tokens)
CONFIGURED_NOTIFIERS=""
if [ -n "$WEBHOOK_URL" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} webhook"; fi
if [ -n "$APPRISE_URL" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} apprise"; fi
if [ -n "$NOTIFY_GOTIFY_URL" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} gotify"; fi
if [ -n "$NOTIFY_DISCORD_WEBHOOK" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} discord"; fi
if [ -n "$NOTIFY_SLACK_WEBHOOK" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} slack"; fi
if [ -n "$NOTIFY_TELEGRAM_TOKEN" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} telegram"; fi
if [ -n "$NOTIFY_PUSHOVER_TOKEN" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} pushover"; fi
if [ -n "$NOTIFY_PUSHBULLET_TOKEN" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} pushbullet"; fi
if [ -n "$NOTIFY_LUNASEA_WEBHOOK" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} lunasea"; fi
if [ -n "$NOTIFY_EMAIL_SMTP" ]; then CONFIGURED_NOTIFIERS="${CONFIGURED_NOTIFIERS} email"; fi
if [ -n "$CONFIGURED_NOTIFIERS" ]; then
  echo "NOTIFICATIONS=${CONFIGURED_NOTIFIERS}"
else
  echo "NOTIFICATIONS=none"
fi
echo "NOTIFY_EVENTS=${NOTIFY_EVENTS} (resolved: ${NOTIFY_EVENTS_RESOLVED})"

# ── Docker API helpers ───────────────────────────────────────────────

docker_curl() {
  curl --max-time "${CURL_TIMEOUT}" --no-buffer -s \
  ${CA} ${CLIENT_KEY} ${CLIENT_CERT} \
  ${UNIX_SOCK} \
  "$@"
}

# ── Notification event filtering ─────────────────────────────────────

# Check if an event category should trigger notifications
# Categories: startup, action_success, action_failure, skip
# shellcheck disable=2039
should_notify() {
  local category="$1"
  case "$category" in
    startup)        echo "$NOTIFY_EVENTS_RESOLVED" | grep -q "startup" && return 0 || return 1 ;;
    action_success) echo "$NOTIFY_EVENTS_RESOLVED" | grep -q "actions" && return 0 || return 1 ;;
    action_failure) echo "$NOTIFY_EVENTS_RESOLVED" | grep -qE "actions|failures" && return 0 || return 1 ;;
    skip)           echo "$NOTIFY_EVENTS_RESOLVED" | grep -q "skips" && return 0 || return 1 ;;
    *)              return 1 ;;
  esac
}

is_debug_notify() {
  echo "$NOTIFY_EVENTS_RESOLVED" | grep -q "debug" && return 0 || return 1
}

# ── Notification services ────────────────────────────────────────────

send_to_gotify() {
  local text="$1"
  if [ -z "$NOTIFY_GOTIFY_URL" ] || [ -z "$NOTIFY_GOTIFY_TOKEN" ]; then return; fi
  curl -s -X POST "${NOTIFY_GOTIFY_URL}/message?token=${NOTIFY_GOTIFY_TOKEN}" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg msg "$text" '{"title":"Docker-Guardian","message":$msg,"priority":5}')" &
}

send_to_discord() {
  local text="$1"
  if [ -z "$NOTIFY_DISCORD_WEBHOOK" ]; then return; fi
  curl -s -X POST "$NOTIFY_DISCORD_WEBHOOK" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg desc "$text" '{"embeds":[{"title":"Docker-Guardian","description":$desc,"color":3066993}]}')" &
}

send_to_slack() {
  local text="$1"
  if [ -z "$NOTIFY_SLACK_WEBHOOK" ]; then return; fi
  curl -s -X POST "$NOTIFY_SLACK_WEBHOOK" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg txt "*Docker-Guardian*\n$text" '{"text":$txt}')" &
}

send_to_telegram() {
  local text="$1"
  if [ -z "$NOTIFY_TELEGRAM_TOKEN" ] || [ -z "$NOTIFY_TELEGRAM_CHAT_ID" ]; then return; fi
  curl -s -X POST "https://api.telegram.org/bot${NOTIFY_TELEGRAM_TOKEN}/sendMessage" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg chat "$NOTIFY_TELEGRAM_CHAT_ID" --arg txt "Docker-Guardian: $text" '{"chat_id":$chat,"text":$txt}')" &
}

send_to_pushover() {
  local text="$1"
  if [ -z "$NOTIFY_PUSHOVER_TOKEN" ] || [ -z "$NOTIFY_PUSHOVER_USER" ]; then return; fi
  curl -s -X POST "https://api.pushover.net/1/messages.json" \
    -d "token=${NOTIFY_PUSHOVER_TOKEN}&user=${NOTIFY_PUSHOVER_USER}&title=Docker-Guardian&message=${text}" &
}

send_to_pushbullet() {
  local text="$1"
  if [ -z "$NOTIFY_PUSHBULLET_TOKEN" ]; then return; fi
  curl -s -X POST "https://api.pushbullet.com/v2/pushes" \
    -H "Access-Token: ${NOTIFY_PUSHBULLET_TOKEN}" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg body "$text" '{"type":"note","title":"Docker-Guardian","body":$body}')" &
}

send_to_lunasea() {
  local text="$1"
  if [ -z "$NOTIFY_LUNASEA_WEBHOOK" ]; then return; fi
  curl -s -X POST "$NOTIFY_LUNASEA_WEBHOOK" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg body "$text" '{"title":"Docker-Guardian","body":$body}')" &
}

send_to_email() {
  local text="$1"
  if [ -z "$NOTIFY_EMAIL_SMTP" ] || [ -z "$NOTIFY_EMAIL_TO" ]; then return; fi
  local subject="Docker-Guardian Alert"
  printf "From: %s\nTo: %s\nSubject: %s\n\n%s" \
    "$NOTIFY_EMAIL_FROM" "$NOTIFY_EMAIL_TO" "$subject" "$text" | \
    curl -s --url "smtp://${NOTIFY_EMAIL_SMTP}" --ssl-reqd \
      --mail-from "$NOTIFY_EMAIL_FROM" --mail-rcpt "$NOTIFY_EMAIL_TO" \
      --user "${NOTIFY_EMAIL_USER}:${NOTIFY_EMAIL_PASS}" -T - &
}

# ── Notification dispatcher ──────────────────────────────────────────

generate_webhook_payload() {
  jq -n --arg key "$WEBHOOK_JSON_KEY" --arg val "$1" '{($key): $val}'
}

generate_apprise_payload() {
  jq -n --arg body "$1" '{"title":"Docker-Guardian","body":$body}'
}

# Internal dispatch — sends to all configured services
_dispatch_notification() {
  local text="$1"

  if is_debug_notify; then
    local DATE
    DATE=$(date +%Y-%m-%dT%H:%M:%S%z)
    [ -n "$WEBHOOK_URL" ] && echo "$DATE [notify] → webhook: $text"
    [ -n "$APPRISE_URL" ] && echo "$DATE [notify] → apprise: $text"
    [ -n "$NOTIFY_GOTIFY_URL" ] && echo "$DATE [notify] → gotify: $text"
    [ -n "$NOTIFY_DISCORD_WEBHOOK" ] && echo "$DATE [notify] → discord: $text"
    [ -n "$NOTIFY_SLACK_WEBHOOK" ] && echo "$DATE [notify] → slack: $text"
    [ -n "$NOTIFY_TELEGRAM_TOKEN" ] && echo "$DATE [notify] → telegram: $text"
    [ -n "$NOTIFY_PUSHOVER_TOKEN" ] && echo "$DATE [notify] → pushover: $text"
    [ -n "$NOTIFY_PUSHBULLET_TOKEN" ] && echo "$DATE [notify] → pushbullet: $text"
    [ -n "$NOTIFY_LUNASEA_WEBHOOK" ] && echo "$DATE [notify] → lunasea: $text"
    [ -n "$NOTIFY_EMAIL_SMTP" ] && echo "$DATE [notify] → email: $text"
  fi

  # Existing services (backward compatible)
  if [ -n "$WEBHOOK_URL" ]; then
    curl -s -X POST -H "Content-type: application/json" \
      -d "$(generate_webhook_payload "$text")" "$WEBHOOK_URL" &
  fi
  if [ -n "$APPRISE_URL" ]; then
    curl -s -X POST -H "Content-type: application/json" \
      -d "$(generate_apprise_payload "$text")" "$APPRISE_URL" &
  fi

  # Native notification services
  send_to_gotify "$text"
  send_to_discord "$text"
  send_to_slack "$text"
  send_to_telegram "$text"
  send_to_pushover "$text"
  send_to_pushbullet "$text"
  send_to_lunasea "$text"
  send_to_email "$text"
}

notify_webhook() {
  local text="$@"
  # Determine if success or failure from the text content
  if echo "$text" | grep -q "Failed"; then
    should_notify action_failure || return 0
  else
    should_notify action_success || return 0
  fi
  _dispatch_notification "$text"
}

notify_skip() {
  local text="$@"
  should_notify skip || return 0
  _dispatch_notification "$text"
}

notify_startup() {
  local text="$@"
  should_notify startup || return 0
  _dispatch_notification "$text"
}

notify_post_restart_script() {
  if [ -n "$POST_RESTART_SCRIPT" ]; then
    "$POST_RESTART_SCRIPT" "$@" &
  fi
}

# ── Guard functions (shared by unhealthy + dependency checks) ────────

# Returns 0 (true) if container was stopped within AUTOHEAL_GRACE_PERIOD seconds
# shellcheck disable=2039
is_within_grace_period() {
  local container_id="$1"

  if [ "$AUTOHEAL_GRACE_PERIOD" -le 0 ] 2>/dev/null; then
    return 1
  fi

  local finished_at
  finished_at=$(docker_curl "${HTTP_ENDPOINT}/containers/${container_id}/json" | \
    jq -r '.State.FinishedAt // empty')

  if [ -z "$finished_at" ]; then
    return 1
  fi

  # Strip nanoseconds and Z for BusyBox date compatibility
  # Docker returns: 2026-01-15T10:30:00.123456789Z
  # BusyBox needs:  2026-01-15 10:30:00
  local clean_ts
  clean_ts=$(echo "$finished_at" | sed 's/T/ /; s/\.[0-9]*Z$//')

  local finished_epoch now_epoch age
  finished_epoch=$(date -u -d "$clean_ts" +%s 2>/dev/null) || return 1
  now_epoch=$(date -u +%s)
  age=$((now_epoch - finished_epoch))

  [ "$age" -lt "$AUTOHEAL_GRACE_PERIOD" ]
}

# Per-cycle cache for backup status
_BACKUP_RUNNING_CACHE=""
_BACKUP_CACHE_CYCLE=""

# Returns 0 (true) if a backup container is currently running
# shellcheck disable=2039
is_backup_running() {
  # Return cached result for this cycle
  if [ "$_BACKUP_CACHE_CYCLE" = "$_CURRENT_CYCLE" ]; then
    [ "$_BACKUP_RUNNING_CACHE" = "yes" ]
    return $?
  fi

  _BACKUP_CACHE_CYCLE="$_CURRENT_CYCLE"
  _BACKUP_RUNNING_CACHE="no"

  local running_containers
  running_containers=$(docker_curl "${HTTP_ENDPOINT}/containers/json?filters=%7B%22status%22%3A%5B%22running%22%5D%7D")

  if [ -n "$AUTOHEAL_BACKUP_CONTAINER" ]; then
    # Check by container name
    if echo "$running_containers" | jq -e ".[] | select(.Names[] | contains(\"/${AUTOHEAL_BACKUP_CONTAINER}\"))" > /dev/null 2>&1; then
      _BACKUP_RUNNING_CACHE="yes"
    fi
  else
    # Auto-detect by image name (docker-volume-backup)
    if echo "$running_containers" | jq -e '.[] | select(.Image | test("docker-volume-backup"))' > /dev/null 2>&1; then
      _BACKUP_RUNNING_CACHE="yes"
    fi
  fi

  [ "$_BACKUP_RUNNING_CACHE" = "yes" ]
}

# Returns 0 (true) if container has the backup-managed label
# shellcheck disable=2039
is_backup_managed() {
  local labels_json="$1"

  if [ -z "$AUTOHEAL_BACKUP_LABEL" ]; then
    return 1
  fi

  echo "$labels_json" | jq -e ".[\"${AUTOHEAL_BACKUP_LABEL}\"]" > /dev/null 2>&1
}

# ── Orchestrator / Watchtower awareness ──────────────────────────────

# Per-cycle cache for orchestration events
_ORCHESTRATOR_ACTIVE_CACHE=""
_ORCHESTRATOR_NAMES_CACHE=""
_ORCHESTRATOR_CACHE_CYCLE=""

# Fetches Docker events from the cooldown window and caches results for this cycle
# shellcheck disable=2039
_fetch_orchestrator_events() {
  if [ "$_ORCHESTRATOR_CACHE_CYCLE" = "$_CURRENT_CYCLE" ]; then
    return
  fi
  _ORCHESTRATOR_CACHE_CYCLE="$_CURRENT_CYCLE"
  _ORCHESTRATOR_ACTIVE_CACHE="no"
  _ORCHESTRATOR_NAMES_CACHE=""

  if [ "$AUTOHEAL_WATCHTOWER_COOLDOWN" -le 0 ] 2>/dev/null; then
    return
  fi

  local now since filters events
  now=$(date -u +%s)
  since=$((now - AUTOHEAL_WATCHTOWER_COOLDOWN))

  if [ "$AUTOHEAL_WATCHTOWER_EVENTS" = "all" ]; then
    # All container lifecycle events
    filters="%7B%22type%22%3A%5B%22container%22%5D%7D"
  else
    # Default (orchestration): only destroy+create (Watchtower signature)
    # Avoids self-triggering from Guardian's own start actions
    filters="%7B%22type%22%3A%5B%22container%22%5D%2C%22action%22%3A%5B%22destroy%22%2C%22create%22%5D%7D"
  fi

  events=$(docker_curl "${HTTP_ENDPOINT}/events?since=${since}&until=${now}&filters=${filters}")

  if [ -n "$events" ]; then
    _ORCHESTRATOR_ACTIVE_CACHE="yes"
    _ORCHESTRATOR_NAMES_CACHE=$(echo "$events" | jq -r '.Actor.Attributes.name // empty' 2>/dev/null | sort -u)
    local event_count
    event_count=$(echo "$events" | wc -l)
    local date_str
    date_str=$(date +%d-%m-%Y" "%H:%M:%S)
    echo "$date_str Orchestration activity detected: ${event_count} container event(s) within ${AUTOHEAL_WATCHTOWER_COOLDOWN}s cooldown"
  fi
}

# Returns 0 (true) if any orchestration activity detected within cooldown window
is_orchestrator_active() {
  _fetch_orchestrator_events
  [ "$_ORCHESTRATOR_ACTIVE_CACHE" = "yes" ]
}

# Returns 0 (true) if this specific container has orchestration events
# shellcheck disable=2039
is_container_in_orchestration() {
  local container_name="$1"
  _fetch_orchestrator_events

  if [ "$_ORCHESTRATOR_ACTIVE_CACHE" != "yes" ]; then
    return 1
  fi

  # Strip leading / from container name for matching
  local clean_name="${container_name#/}"
  echo "$_ORCHESTRATOR_NAMES_CACHE" | grep -qF "$clean_name"
}

# ── Skip logic (shared by unhealthy + dependency checks) ────────────

# Returns 0 (true) if this container should be skipped
# shellcheck disable=2039
should_skip_container() {
  local container_id="$1"
  local container_name="$2"
  local labels_json="$3"
  local date_str
  date_str=$(date +%d-%m-%Y" "%H:%M:%S)

  # Check orchestrator activity (Watchtower, etc.)
  if [ "$AUTOHEAL_WATCHTOWER_COOLDOWN" -gt 0 ] 2>/dev/null; then
    if [ "$AUTOHEAL_WATCHTOWER_SCOPE" = "affected" ]; then
      if is_container_in_orchestration "$container_name"; then
        echo "$date_str Container $container_name (${container_id:0:12}) affected by orchestration activity within ${AUTOHEAL_WATCHTOWER_COOLDOWN}s - skipping"
        notify_skip "Container ${container_name#/} (${container_id:0:12}) skipped - orchestration activity"
        return 0
      fi
    else
      # Default (all): skip ALL containers when any orchestration detected
      if is_orchestrator_active; then
        echo "$date_str Container $container_name (${container_id:0:12}) skipped - orchestration activity detected within ${AUTOHEAL_WATCHTOWER_COOLDOWN}s"
        notify_skip "Container ${container_name#/} (${container_id:0:12}) skipped - orchestration activity"
        return 0
      fi
    fi
  fi

  # Check grace period (fallback)
  if is_within_grace_period "$container_id"; then
    echo "$date_str Container $container_name (${container_id:0:12}) stopped within grace period (${AUTOHEAL_GRACE_PERIOD}s) - skipping"
    notify_skip "Container ${container_name#/} (${container_id:0:12}) skipped - grace period"
    return 0
  fi

  # Check backup awareness
  if is_backup_managed "$labels_json" && is_backup_running; then
    echo "$date_str Container $container_name (${container_id:0:12}) managed by backup (currently running) - skipping"
    notify_skip "Container ${container_name#/} (${container_id:0:12}) skipped - backup running"
    return 0
  fi

  return 1
}

# ── Original autoheal: unhealthy container monitoring ────────────────

# shellcheck disable=2039
get_container_info() {
  local label_filter
  local running_filter
  local url

  if [ "$AUTOHEAL_CONTAINER_LABEL" = "all" ]; then
    label_filter=""
  else
    label_filter=",\"label\":\[\"${AUTOHEAL_CONTAINER_LABEL}=true\"\]"
  fi
  if [ "$AUTOHEAL_ONLY_MONITOR_RUNNING" = false ]; then
    running_filter=""
  else
    running_filter=",\"status\":\[\"running\"\]"
  fi
  url="${HTTP_ENDPOINT}/containers/json?filters=\{\"health\":\[\"unhealthy\"\]${label_filter}${running_filter}\}"
  docker_curl "$url"
}

restart_container() {
  local container_id="$1"
  local timeout="$2"

  docker_curl -f -X POST "${HTTP_ENDPOINT}/containers/${container_id}/restart?t=${timeout}"
}

# shellcheck disable=2039
check_unhealthy() {
  get_container_info | \
    jq -r '.[] | select(.Labels["autoheal"] != "False") | foreach . as $CONTAINER([];[]; $CONTAINER | .Id, .Names[0], .State, (.Labels | tojson), (.Labels["autoheal.stop.timeout"] // '"$AUTOHEAL_DEFAULT_STOP_TIMEOUT"'))' | \
    while read -r CONTAINER_ID && read -r CONTAINER_NAME && read -r CONTAINER_STATE && read -r CONTAINER_LABELS && read -r TIMEOUT
  do
    # shellcheck disable=2039
    CONTAINER_SHORT_ID=${CONTAINER_ID:0:12}
    DATE=$(date +%d-%m-%Y" "%H:%M:%S)

    if [ "$CONTAINER_NAME" = "null" ]; then
      echo "$DATE Container name of (${CONTAINER_SHORT_ID}) is null, which implies container does not exist - don't restart" >&2
    elif [ "$CONTAINER_STATE" = "restarting" ]; then
      echo "$DATE Container $CONTAINER_NAME (${CONTAINER_SHORT_ID}) found to be restarting - don't restart"
    elif should_skip_container "$CONTAINER_ID" "$CONTAINER_NAME" "$CONTAINER_LABELS"; then
      : # skip message already printed by should_skip_container
    else
      echo "$DATE Container $CONTAINER_NAME (${CONTAINER_SHORT_ID}) found to be unhealthy - Restarting container now with ${TIMEOUT}s timeout"
      if ! restart_container "$CONTAINER_ID" "$TIMEOUT"; then
        echo "$DATE Restarting container $CONTAINER_SHORT_ID failed" >&2
        notify_webhook "Container ${CONTAINER_NAME#/} (${CONTAINER_SHORT_ID}) found to be unhealthy. Failed to restart the container!"
      else
        notify_webhook "Container ${CONTAINER_NAME#/} (${CONTAINER_SHORT_ID}) found to be unhealthy. Successfully restarted the container!"
      fi
      notify_post_restart_script "$CONTAINER_NAME" "$CONTAINER_SHORT_ID" "$CONTAINER_STATE" "$TIMEOUT"
    fi
  done
}

# ── Feature 1: Dependency orphan monitoring ──────────────────────────

start_container() {
  local container_id="$1"
  docker_curl -f -X POST "${HTTP_ENDPOINT}/containers/${container_id}/start"
}

# shellcheck disable=2039
check_dependency_orphans() {
  if [ "$AUTOHEAL_MONITOR_DEPENDENCIES" != "true" ]; then
    return
  fi

  # Get all exited containers
  local exited
  exited=$(docker_curl "${HTTP_ENDPOINT}/containers/json?all=true&filters=%7B%22status%22%3A%5B%22exited%22%5D%7D")

  if [ -z "$exited" ] || [ "$exited" = "[]" ] || [ "$exited" = "null" ]; then
    return
  fi

  # Extract IDs of exited containers
  echo "$exited" | jq -r '.[].Id' | while read -r CONTAINER_ID; do
    [ -z "$CONTAINER_ID" ] && continue

    # Inspect to get NetworkMode, exit code, name, labels
    local inspect
    inspect=$(docker_curl "${HTTP_ENDPOINT}/containers/${CONTAINER_ID}/json")

    [ -z "$inspect" ] || [ "$inspect" = "null" ] && continue

    local network_mode exit_code container_name labels_json
    network_mode=$(echo "$inspect" | jq -r '.HostConfig.NetworkMode // empty')
    exit_code=$(echo "$inspect" | jq -r '.State.ExitCode // empty')
    container_name=$(echo "$inspect" | jq -r '.Name // empty')
    labels_json=$(echo "$inspect" | jq -r '.Config.Labels // {}')

    # Only act on containers using container:X network mode
    case "$network_mode" in
      container:*) ;;
      *) continue ;;
    esac

    # Extract parent container ID from network mode
    local parent_id
    parent_id=${network_mode#container:}

    # Check parent is running (not restarting, not exited)
    local parent_state
    parent_state=$(docker_curl "${HTTP_ENDPOINT}/containers/${parent_id}/json" | \
      jq -r '.State.Status // empty' 2>/dev/null)

    if [ "$parent_state" != "running" ]; then
      continue
    fi

    # shellcheck disable=2039
    local short_id="${CONTAINER_ID:0:12}"
    local DATE
    DATE=$(date +%d-%m-%Y" "%H:%M:%S)

    # Apply guards
    if should_skip_container "$CONTAINER_ID" "$container_name" "$labels_json"; then
      continue
    fi

    echo "$DATE Container $container_name ($short_id) exited (code $exit_code, orphaned dependent) - parent ${parent_id:0:12} is running"

    # Wait for start delay, then re-verify parent
    if [ "$AUTOHEAL_DEPENDENCY_START_DELAY" -gt 0 ] 2>/dev/null; then
      echo "$DATE Waiting ${AUTOHEAL_DEPENDENCY_START_DELAY}s before starting $container_name..."
      sleep "$AUTOHEAL_DEPENDENCY_START_DELAY"

      # Re-check parent is still running
      parent_state=$(docker_curl "${HTTP_ENDPOINT}/containers/${parent_id}/json" | \
        jq -r '.State.Status // empty' 2>/dev/null)
      if [ "$parent_state" != "running" ]; then
        echo "$DATE Parent ${parent_id:0:12} no longer running after delay - skipping $container_name"
        continue
      fi
    fi

    # Re-check container is still exited (Docker restart policy may have handled it)
    local current_state
    current_state=$(docker_curl "${HTTP_ENDPOINT}/containers/${CONTAINER_ID}/json" | \
      jq -r '.State.Status // empty' 2>/dev/null)
    if [ "$current_state" != "exited" ]; then
      echo "$DATE Container $container_name ($short_id) is now $current_state - no action needed"
      continue
    fi

    echo "$DATE Starting orphaned dependent $container_name ($short_id)..."
    if ! start_container "$CONTAINER_ID"; then
      echo "$DATE Failed to start $container_name ($short_id)" >&2
      notify_webhook "Container ${container_name#/} ($short_id) orphaned (parent running). Failed to start!"
    else
      echo "$DATE Successfully started $container_name ($short_id)"
      notify_webhook "Container ${container_name#/} ($short_id) orphaned (parent running). Successfully started!"
    fi
    notify_post_restart_script "$container_name" "$short_id" "orphaned" "0"
  done
}

# ── Signal handling ──────────────────────────────────────────────────

term_handler() {
  exit 143  # 128 + 15 -- SIGTERM
}

# shellcheck disable=2039
trap 'kill $$; term_handler' SIGTERM

# ── Main loop ────────────────────────────────────────────────────────

if [ "$1" = "autoheal" ]; then
  if [ -n "$UNIX_SOCK" ] && ! [ -S "$DOCKER_SOCK" ]; then
    echo "unix socket is currently not available" >&2
    exit 1
  fi

  # Delayed startup
  if [ "$AUTOHEAL_START_PERIOD" -gt 0 ]; then
    echo "Monitoring containers in $AUTOHEAL_START_PERIOD second(s)"
    sleep "$AUTOHEAL_START_PERIOD" &
    wait $!
  fi

  # Send startup notification if enabled
  notify_startup "Docker-Guardian started. Monitoring active. Services:${CONFIGURED_NOTIFIERS:- none}"

  _CURRENT_CYCLE=0

  while true; do
    _CURRENT_CYCLE=$((_CURRENT_CYCLE + 1))

    # Check 1: unhealthy containers (original autoheal)
    check_unhealthy

    # Check 2: dependency orphans (Docker-Guardian)
    check_dependency_orphans

    sleep "$AUTOHEAL_INTERVAL" &
    wait $!
  done

else
  exec "$@"
fi
